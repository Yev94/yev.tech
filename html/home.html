<h1>Yev <img src="./img/astronaut-circle.gif" alt=""> Tech</a></h1>
<section>
    <!-- <div class="code">
        <pre >
          <code class="language-javascript">
          </code>
        </pre>
      </div> -->
    <script defer src="https://gist.github.com/Yev94/c71bfd2b99a17e5031ab85759fe4e7cc.js"></script>
    <section>
        <img src="./img/estudiar-codificar.svg" alt="">
        <h2>Codificar</h2>
        <h3>Entender la lógica previa</h3>
        <p>Se trata de reconocer los Inputs, Outputs y la sintaxis en la que está escrito el código.</p>
        <p>Esta, bien puede ser reconocida por asociación porque ya se conocen modelos lógicos anteriores(Modelos
            lógicos prefabricados).</p>
        <p>O bien es un nuevo modelo lógico que tiene que ser estudiado.</p>
        <h3>Crear mi propia lógica</h3>
        <p>Se trata de reconocer y escribir los Inputs y Outputs, además de la secuencia en la que se tienen que
            dar.</p>
        <p>Por lo que se creará con una mezcla entre modelos lógicos conocidos y modelos lógicos nuevos.</p>
        <h3>De nuevo modelo a modelo prefabricado</h3>
        <p>Los pasos necesarios son:</p>
        <ol>
            <li>Búsqueda de información</li>
            <li>Entendimiento</li>
            <li>Creación del modelo mental</li>
            <li>Guardado y creación de puertas de acceso</li>
        </ol>
        <h4>Entendimiento</h4>
        <p>Se trata de conocer las secuencias lógicas, en la que se aprende a reconocer los Inputs y Outputs, y los
            factores y funciones que componen la secuencia.</p>
        <p>Se puede abordar de 2 maneras:</p>
        <ol>
            <li>Conocer los Inputs/Outputs, lanzar una hipótesis de todo aquello necesario que lo genere y
                contrastar esa hipótesis (De tal manera que se entiende de manera activa, asociando el nuevo
                contenido en la memoria de trabajo con el contenido de la memoria a l/p).</li>
            <li>Conocer los inputs, conocer todo aquello necesario que genere los outputs y, por último, los outputs
                (En este caso se usa únicamente la memoria de trabajo y se lleva al l/p, por lo que es útil para
                todos aquellos que tienen una memoria de trabajo extensa o bien para aquellos que ya tienen ciertas
                asociaciones con el modelo, o que conocen modelos más abstractos).</li>
        </ol>
        <h4>Guardado y creación de puertas de acceso</h4>
        <p>Sí se prevé que el nuevo modelo mental será usado de cara al futuro, es necesario guardarlo en un espacio
            físico (los apuntes de toda la vida) con un sistema de clasificación que permita guardarlo de tal manera
            que pueda ser encontrado de manera sencilla en el futuro.</p>
        <p>En el caso de que se necesario tener un acceso recurrente al mismo, se crearán puertas de acceso rápido
            para eliminar cualquier fricción de revisión.</p>
        <p>Por otro lado, si se prevé que será necesario acceder al modelo de manera rápida y/o que será necesario
            su acceso sin poder contar con el acceso físico, será necesario guardarlo en la memoria, lo cual
            requiere de repetición espaciada para asegurarse que no existen olvidos en ninguna parte del mismo.</p>
        <h4>Sintaxis y escritura</h4>
        <p>Siguen la misma secuencia que los modelos en cuanto a su entendimiento y memorización en cuanto al
            reconocimiento de la sintaxis.</p>
        <p>En cuanto a la propia escritura de la sintaxis, para aumentar la eficiencia, es necesario minimizar el
            tipeo de la sintaxis, por lo que se hará uso de la prefabricación de la sintaxis para disminuir el
            mismo.</p>
    </section>
    <section>
        <h2>Hacer elecciones</h2>
        <p>Sea cual sea la elección, si es por algo nuevo, documentarlo todo y ver la manera de que sea una inversión y no un gasto.</p>
        <h3>Entre Lenguajes</h3>
        <p>Elegir los mejores lenguajes que se adapter a los requerimientos de lo que programarás.</p>
        <p>Ver cuál de ellos tiene mayor soporte por la comunidad.</p>
        <h3>Entre soluciones ya creadas o elaboración propia</h3>
        <p>Ver si solucionan funcionalidades importantes del programa (para ahorrar tiempo en la implementación inicial), por lo que solo haya que agregarle ciertas cosas nuevas.</p>
        <p>Ver si tiene una buena comunidad para ver si vale la pena aprender su arquitectura.</p>
        <p>Ver si la voy a utilizar en más de una ocasión.</p>
        <p>Si hay tutoriales, además de documentarlo todo, hacer shorts en soluciones concretas.</p>
        <p>Si hay cursos de pago, hacer tutoriales.</p>
    </section>